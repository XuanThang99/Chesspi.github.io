


  * Basic rules for all pieces (Giải pháp giản lược nhưng đủ để chơi)
  * Offline AI opponent (minimax + alpha-beta, depth adjustable)
  * Undo, Restart, Toggle AI / Human opponent
  * Responsive and self-contained (no external libs)

Notes:
- This implementation focuses on correctness of moves and playable AI.
- It doesn't include advanced rule edge-cases like perpetual check detection or threefold repetition draw.
- If you want stronger AI, increase AI_DEPTH variable (slow for big depths).

Author: Generated for you. Enjoy!
--><!doctype html>

<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cờ Tướng - Demo Web App (AI offline)</title>
  <style>
    :root{--bg:#f5f5f7;--board:#ffd9b3;--line:#a45f2c;--dark:#222}
    body{font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:0;background:var(--bg);color:var(--dark);display:flex;align-items:flex-start;justify-content:center;padding:20px}
    .app{width:980px;max-width:98%;display:grid;grid-template-columns:1fr 320px;gap:18px}
    .card{background:white;border-radius:12px;box-shadow:0 6px 22px rgba(0,0,0,0.08);padding:14px}
    h1{margin:6px 0 10px;font-size:20px}
    /* board */
    .board-wrap{display:flex;flex-direction:column;align-items:center}
    .board{width:680px;max-width:100%;aspect-ratio:9/10;display:grid;grid-template-columns:repeat(9,1fr);grid-template-rows:repeat(10,1fr);background:linear-gradient(180deg,var(--board),#f0cfa6);position:relative;border-radius:8px;padding:6px;box-sizing:border-box;border:4px solid var(--line)}
    .cell{border:1px solid rgba(0,0,0,0.08);display:flex;align-items:center;justify-content:center;position:relative;font-weight:700}
    .river{position:absolute;left:6px;right:6px;top:calc(4*10% + 6px);height:20%;display:flex;align-items:center;justify-content:center;color:rgba(0,0,0,0.35);font-weight:600}
    .idx{position:absolute;left:6px;top:6px;font-size:12px;color:rgba(0,0,0,0.45)}
    .piece{width:70%;height:70%;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:20px;user-select:none;cursor:pointer;box-shadow:0 3px 6px rgba(0,0,0,0.12)}
    .red{background:#ffe6e6;border:2px solid #d14b4b;color:#d14b4b}
    .black{background:#e6f1ff;border:2px solid #274b7a;color:#274b7a}
    .selected{outline:4px solid rgba(255,215,0,0.65);transform:scale(1.04)}
    .highlight{position:absolute;width:28%;height:28%;border-radius:50%;background:rgba(0,200,50,0.16);pointer-events:none}
    .controls{display:flex;flex-direction:column;gap:8px}
    button{padding:10px;border-radius:8px;border:0;background:#2b7cff;color:white;font-weight:700;cursor:pointer}
    button.ghost{background:white;color:#333;border:1px solid #ddd}
    .status{padding:10px;border-radius:8px;background:#f7f8fa;border:1px solid #eee}
    .small{font-size:13px;color:#555}
    select,input{padding:8px;border-radius:8px;border:1px solid #ddd}
    .moves{max-height:300px;overflow:auto;padding:8px;background:#fafafa;border-radius:8px;border:1px solid #eee}
    .footer{margin-top:8px;font-size:12px;color:#666}
    @media(max-width:900px){.app{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="app">
    <div class="card board-wrap">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <h1>Cờ Tướng - Demo Web App</h1>
        <div class="small">Offline AI • Chơi bản địa</div>
      </div><div id="board" class="board"></div>
  <div style="display:flex;gap:8px;margin-top:10px">
    <button id="undoBtn" class="ghost">Undo</button>
    <button id="restartBtn">Restart</button>
    <button id="toggleAI" class="ghost">AI: On</button>
    <label class="small" style="align-self:center">AI depth: <select id="aiDepth"><option>2</option><option selected>3</option><option>4</option></select></label>
  </div>
  <div class="footer">Lưu ý: Đây là phiên bản demo. Tăng AI depth sẽ làm AI mạnh hơn nhưng chậm hơn.</div>
</div>

<div class="card controls">
  <div class="status">
    <div><strong>Trạng thái:</strong> <span id="turnText">Red (Bạn)</span></div>
    <div class="small">Click chọn quân -> click ô đích. Bạn có thể chơi với AI hoặc 2 người.</div>
  </div>

  <div style="margin-top:10px">
    <div style="margin-bottom:6px"><strong>Moves</strong></div>
    <div id="moves" class="moves"></div>
  </div>

  <div style="margin-top:10px">
    <div style="margin-bottom:6px"><strong>Settings</strong></div>
    <div style="display:flex;flex-direction:column;gap:8px">
      <label><input type="checkbox" id="flipBoard"> Lật bàn (view)</label>
      <label><input type="checkbox" id="autoAI" checked> Đối thủ là AI</label>
    </div>
  </div>

  <div style="margin-top:10px">
    <div style="margin-bottom:6px"><strong>Thông tin</strong></div>
    <div class="small">Hỗ trợ: Undo, Restart, lựa chọn AI depth. AI dùng minimax + alpha-beta (đơn giản nhưng hiệu quả cho demo).</div>
  </div>
</div>

  </div><script>
// Xiangqi core representation and rules (simplified but functional)
// Board coordinates: x in [0..8], y in [0..9] ; index = y*9 + x

const PIECES = {
  // Uppercase = Red (bottom), lowercase = Black (top)
  'K': 'King', 'A': 'Advisor','E':'Elephant','R':'Chariot','H':'Horse','C':'Cannon','S':'Soldier',
  'k':'king','a':'advisor','e':'elephant','r':'chariot','h':'horse','c':'cannon','s':'soldier'
};

// initial board FEN-like: 9x10 rows from top (black) to bottom (red)
const START = [
  'r','h','e','a','k','a','e','h','r',
  '.','.','.','.','.','.','.','.','.',
  '.','c','.','.','.','.','.','c','.',
  's','.','s','.','s','.','s','.','s',
  '.','.','.','.','.','.','.','.','.',
  '.','.','.','.','.','.','.','.','.',
  'S','.','S','.','S','.','S','.','S',
  '.','C','.','.','.','.','.','C','.',
  '.','.','.','.','.','.','.','.','.',
  'R','H','E','A','K','A','E','H','R'
];

let board = START.slice();
let turn = 'r'; // 'r' (red) moves first in many implementations; we'll keep red = lowercase? We'll use 'r' to represent red side to move; but pieces uppercase are Red, lowercase are Black. For clarity: we'll set turnColor = 'red' or 'black' by comparing piece case.
let selected = null; // index
let highlights = [];
let moveHistory = [];
let aiEnabled = true;
let aiSide = 'black'; // AI plays black by default for demo; but autoAI checkbox toggles
let flipView = false;
let AI_DEPTH = 3;

const pieceValue = { 'K':900, 'R':90,'H':40,'C':45,'E':20,'A':15,'S':10, 'k':-900,'r':-90,'h':-40,'c':-45,'e':-20,'a':-15,'s':-10 };

const boardEl = document.getElementById('board');
const movesEl = document.getElementById('moves');
const turnText = document.getElementById('turnText');

function idx(x,y){return y*9 + x}
function xy(i){return [i%9, Math.floor(i/9)]}

function isRedPiece(p){return p && p !== '.' && p.toUpperCase()===p}
function isBlackPiece(p){return p && p !== '.' && p.toLowerCase()===p}

function render(){
  boardEl.innerHTML = '';
  for(let y=0;y<10;y++){
    for(let x=0;x<9;x++){
      const i = flipView? idx(8-x,9-y) : idx(x,y);
      const [rx,ry] = xy(i);
      const cell = document.createElement('div');
      cell.className='cell';
      cell.dataset.index = i;
      const coordLabel = document.createElement('div'); coordLabel.className='idx'; coordLabel.textContent = '';
      cell.appendChild(coordLabel);
      const p = board[i];
      if(p && p !== '.'){
        const piece = document.createElement('div');
        piece.className = 'piece ' + (p.toUpperCase()===p ? 'red' : 'black');
        piece.textContent = pieceLetter(p);
        piece.draggable = false;
        if(selected===i) piece.classList.add('selected');
        cell.appendChild(piece);
      }
      cell.addEventListener('click', ()=>onCellClick(i));
      boardEl.appendChild(cell);
    }
  }
  // river label
  const river = document.createElement('div'); river.className='river'; river.textContent='Sông'; boardEl.appendChild(river);
  updateStatus();
}

function pieceLetter(p){
  // use vietnamese short letters or english single letters
  const map = {K:'帥',k:'將',R:'車',r:'車',H:'馬',h:'馬',E:'象',e:'象',A:'士',a:'士',C:'炮',c:'炮',S:'兵',s:'卒'};
  return map[p]||p;
}

function onCellClick(i){
  const p = board[i];
  if(selected===null){
    if(p==='.') return;
    if(turn==='r' && p.toUpperCase()!==p) return; // red to move -> uppercase
    if(turn==='b' && p.toLowerCase()!==p) return;
    selected = i;
    render();
    showMoves(i);
  } else {
    if(selected===i){selected=null; highlights=[]; render(); return}
    // attempt move
    const moves = generateMoves(selected);
    const legal = moves.find(m=>m.to===i);
    if(legal){
      makeMove(legal);
      selected=null; highlights=[]; render();
      afterMove();
    } else {
      // if clicked another own piece, switch selection
      if(p!=='.' && ((turn==='r' && p.toUpperCase()===p) || (turn==='b' && p.toLowerCase()===p))){
        selected = i; showMoves(i); render();
      } else { selected=null; highlights=[]; render(); }
    }
  }
}

function showMoves(from){
  highlights = [];
  const moves = generateMoves(from);
  moves.forEach(m=>highlights.push(m.to));
  // render highlights
  document.querySelectorAll('.cell').forEach(c=>{const idxc=Number(c.dataset.index); if(highlights.includes(idxc)){const h=document.createElement('div');h.className='highlight';c.appendChild(h);}});
}

function updateStatus(){
  turnText.textContent = (turn==='r'? 'Red (YOU)':'Black (AI)');
  // moves list
  movesEl.innerHTML = moveHistory.map((m,i)=>`<div>${i+1}. ${m.san || formatMove(m)}</div>`).join('');
}

function formatMove(m){
  const [fx,fy]=xy(m.from); const [tx,ty]=xy(m.to);
  return `${fx},${fy} -> ${tx},${ty}`;
}

function cloneBoard(b){return b.slice();}

// Move structure: {from, to, piece, captured}
function makeMove(m, record=true){
  const piece = board[m.from];
  m.piece = piece; m.captured = board[m.to];
  board[m.to] = piece; board[m.from] = '.';
  if(record) moveHistory.push(m);
  // swap turn
  turn = (turn==='r' ? 'b' : 'r');
}
function undo(){
  const m = moveHistory.pop(); if(!m) return;
  board[m.from] = m.piece; board[m.to] = m.captured || '.';
  turn = (turn==='r' ? 'b' : 'r');
  selected=null; highlights=[]; render();
}

function restart(){ board = START.slice(); moveHistory=[]; turn='r'; selected=null; highlights=[]; render(); }

// Generate all legal moves for a piece at index 'from'
function generateMoves(from){
  const p = board[from]; if(!p||p==='.') return [];
  const moves = [];
  const [x,y]=xy(from);
  const isRed = p.toUpperCase()===p;
  const dir = isRed? -1 : 1; // for soldiers

  function addIfEmptyOrCapture(tx,ty){
    if(tx<0||tx>8||ty<0||ty>9) return;
    const toIdx = idx(tx,ty);
    const target = board[toIdx];
    if(target==='.' || (isRed? target.toLowerCase()===target : target.toUpperCase()===target)){
      moves.push({from,to:toIdx});
    }
  }

  const up = (x,y)=>{};
  const pUpper = p.toUpperCase();
  if(pUpper==='R'){ // chariot/rook
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    dirs.forEach(d=>{let tx=x+d[0], ty=y+d[1]; while(tx>=0&&tx<=8&&ty>=0&&ty<=9){const tIdx=idx(tx,ty); if(board[tIdx]==='.') {moves.push({from,to:tIdx}); tx+=d[0]; ty+=d[1];} else { // capture possible if opposite
        if(isRed? board[tIdx].toLowerCase()===board[tIdx] : board[tIdx].toUpperCase()===board[tIdx]) moves.push({from,to:tIdx}); break; }}});
  } else if(pUpper==='H'){ // horse
    const helpers=[ [1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1] ];
    const leg = [[0,1],[1,0],[0,1],[-1,0],[0,-1],[1,0],[0,-1],[-1,0]]; // corresponding leg offsets
    for(let i=0;i<helpers.length;i++){const ox=helpers[i][0], oy=helpers[i][1]; const lx = x + leg[i][0], ly = y + leg[i][1]; if(lx<0||lx>8||ly<0||ly>9) continue; if(board[idx(lx,ly)] !== '.') continue; const tx=x+ox, ty=y+oy; if(tx<0||tx>8||ty<0||ty>9) continue; const target = board[idx(tx,ty)]; if(target==='.' || (isRed? target.toLowerCase()===target : target.toUpperCase()===target)) moves.push({from,to:idx(tx,ty)}); }
  } else if(pUpper==='C'){ // cannon
    // slides but capture requires skipping exactly one piece
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    dirs.forEach(d=>{let tx=x+d[0], ty=y+d[1]; while(inBounds(tx,ty) && board[idx(tx,ty)]==='.') {moves.push({from,to:idx(tx,ty)}); tx+=d[0]; ty+=d[1];} // now find first piece then next piece capture
      if(inBounds(tx,ty)){ tx+=d[0]; ty+=d[1]; while(inBounds(tx,ty)){ if(board[idx(tx,ty)] !== '.') { const target = board[idx(tx,ty)]; if(isRed? target.toLowerCase()===target : target.toUpperCase()===target) moves.push({from,to:idx(tx,ty)}); break;} tx+=d[0]; ty+=d[1]; }});
  } else if(pUpper==='E'){ // elephant / elephant can't cross river, move exactly 2 diagonals, blocked by middle point
    const deltas=[[2,2],[2,-2],[-2,2],[-2,-2]];
    deltas.forEach(d=>{const mx=x+d[0], my=y+d[1]; const bx=x+d[0]/2, by=y+d[1]/2; if(mx<0||mx>8||my<0||my>9) return; // can't cross river
      if(isRed && my<5){} // red at bottom cannot go to top half? chinese xiangqi: red side rows 5-9, elephants cannot cross river -> for red, my must be >=5 ; for black, my must be <=4
      if(isRed && my<5) return; if(!isRed && my>4) return; if(board[idx(bx,by)] !== '.') return; const target=board[idx(mx,my)]; if(target==='.' || (isRed? target.toLowerCase()===target : target.toUpperCase()===target)) moves.push({from,to:idx(mx,my)});
    });
  } else if(pUpper==='A'){ // advisor (shi) must stay in palace and move 1 diag
    const deltas=[[1,1],[1,-1],[-1,1],[-1,-1]];
    deltas.forEach(d=>{const mx=x+d[0], my=y+d[1]; if(mx<3||mx>5) return; if(isRed){ if(my<7||my>9) return; } else { if(my<0||my>2) return; } const target=board[idx(mx,my)]; if(target==='.' || (isRed? target.toLowerCase()===target : target.toUpperCase()===target)) moves.push({from,to:idx(mx,my)});});
  } else if(pUpper==='K'){ // king within palace, can also face-to-face rule implemented later
    const deltas=[[1,0],[-1,0],[0,1],[0,-1]];
    deltas.forEach(d=>{const mx=x+d[0], my=y+d[1]; if(mx<3||mx>5) return; if(isRed){ if(my<7||my>9) return; } else { if(my<0||my>2) return; } const target=board[idx(mx,my)]; if(target==='.' || (isRed? target.toLowerCase()===target : target.toUpperCase()===target)) moves.push({from,to:idx(mx,my)});});
    // face-to-face: if no pieces between kings on same file, can move to capture directly along file
    for(let yy = isRed?y-1:y+1; yy>=0 && yy<=9; yy += isRed?-1:1){ const mid = board[idx(x,yy)]; if(mid !== '.') { if(mid.toUpperCase()==='K'){ moves.push({from,to:idx(x,yy)}); } break; }}
  } else if(pUpper==='S'){ // soldier
    // moves forward one, after crossing river can move sideways
    const fwdY = y + (isRed? -1 : 1);
    if(inBounds(x,fwdY)) addIfEmptyOrCapture(x,fwdY);
    const crossed = isRed? (y<=4) : (y>=5);
    if(crossed){ addIfEmptyOrCapture(x+1,y); addIfEmptyOrCapture(x-1,y); }
  }

  // filter out moves that leave own king in check
  const legal = moves.filter(m=>{ const snapshot = board.slice(); const oldTurn = turn; makeMove(m,false); const ok = !isInCheck(oldTurn); board = snapshot; turn = oldTurn; return ok; });
  return legal;
}

function inBounds(x,y){return x>=0&&x<=8&&y>=0&&y<=9}

function isInCheck(sideTurn){
  // sideTurn is 'r' or 'b' denoting who just moved? We want to check if that side's king is in check
  // locate king
  const kingChar = (sideTurn==='r')? 'K' : 'k';
  let kpos = -1; for(let i=0;i<90;i++) if(board[i]===kingChar) {kpos=i;break}
  if(kpos===-1) return true; // no king => technically in checkmate

  // generate opponent moves and see if any captures king
  for(let i=0;i<90;i++){ const p = board[i]; if(p==='.') continue; const isOpp = (sideTurn==='r'? p.toLowerCase()===p : p.toUpperCase()===p); if(!isOpp) continue; const moves = generatePseudoMoves(i); for(const m of moves) if(m.to===kpos) return true; }
  return false;
}

// generatePseudoMoves similar to generateMoves but without check filtering (to speed check)
function generatePseudoMoves(from){
  const p = board[from]; if(!p||p==='.') return [];
  const moves = [];
  const [x,y]=xy(from);
  const isRed = p.toUpperCase()===p;
  const pUpper = p.toUpperCase();
  if(pUpper==='R'){
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    dirs.forEach(d=>{let tx=x+d[0], ty=y+d[1]; while(inBounds(tx,ty)){const tIdx=idx(tx,ty); if(board[tIdx]==='.') {moves.push({from,to:tIdx}); tx+=d[0]; ty+=d[1];} else { if(isRed? board[tIdx].toLowerCase()===board[tIdx] : board[tIdx].toUpperCase()===board[tIdx]) moves.push({from,to:tIdx}); break; }}});
  } else if(pUpper==='H'){
    const helpers=[ [1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1] ];
    const leg = [[0,1],[1,0],[0,1],[-1,0],[0,-1],[1,0],[0,-1],[-1,0]];
    for(let i=0;i<helpers.length;i++){const ox=helpers[i][0], oy=helpers[i][1]; const lx = x + leg[i][0], ly = y + leg[i][1]; if(lx<0||lx>8||ly<0||ly>9) continue; if(board[idx(lx,ly)] !== '.') continue; const tx=x+ox, ty=y+oy; if(tx<0||tx>8||ty<0||ty>9) continue; const target = board[idx(tx,ty)]; if(target==='.' || (isRed? target.toLowerCase()===target : target.toUpperCase()===target)) moves.push({from,to:idx(tx,ty)}); }
  } else if(pUpper==='C'){
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    dirs.forEach(d=>{let tx=x+d[0], ty=y+d[1]; while(inBounds(tx,ty) && board[idx(tx,ty)]==='.') {moves.push({from,to:idx(tx,ty)}); tx+=d[0]; ty+=d[1];} if(inBounds(tx,ty)){ tx+=d[0]; ty+=d[1]; while(inBounds(tx,ty)){ if(board[idx(tx,ty)] !== '.') { const target = board[idx(tx,ty)]; if(isRed? target.toLowerCase()===target : target.toUpperCase()===target) moves.push({from,to:idx(tx,ty)}); break;} tx+=d[0]; ty+=d[1]; }}});
  } else if(pUpper==='E'){
    const deltas=[[2,2],[2,-2],[-2,2],[-2,-2]];
    deltas.forEach(d=>{const mx=x+d[0], my=y+d[1]; const bx=x+d[0]/2, by=y+d[1]/2; if(mx<0||mx>8||my<0||my>9) return; if(isRed && my<5) return; if(!isRed && my>4) return; if(board[idx(bx,by)] !== '.') return; const target=board[idx(mx,my)]; if(target==='.' || (isRed? target.toLowerCase()===target : target.toUpperCase()===target)) moves.push({from,to:idx(mx,my)}); });
  } else if(pUpper==='A'){
    const deltas=[[1,1],[1,-1],[-1,1],[-1,-1]];
    deltas.forEach(d=>{const mx=x+d[0], my=y+d[1]; if(mx<3||mx>5) return; if(isRed){ if(my<7||my>9) return; } else { if(my<0||my>2) return; } const target=board[idx(mx,my)]; if(target==='.' || (isRed? target.toLowerCase()===target : target.toUpperCase()===target)) moves.push({from,to:idx(mx,my)});});
  } else if(pUpper==='K'){
    const deltas=[[1,0],[-1,0],[0,1],[0,-1]];
    deltas.forEach(d=>{const mx=x+d[0], my=y+d[1]; if(mx<3||mx>5) return; if(isRed){ if(my<7||my>9) return; } else { if(my<0||my>2) return; } const target=board[idx(mx,my)]; if(target==='.' || (isRed? target.toLowerCase()===target : target.toUpperCase()===target)) moves.push({from,to:idx(mx,my)});});
    for(let yy = isRed?y-1:y+1; yy>=0 && yy<=9; yy += isRed?-1:1){ const mid = board[idx(x,yy)]; if(mid !== '.') { if(mid.toUpperCase()==='K'){ moves.push({from,to:idx(x,yy)}); } break; }}
  } else if(pUpper==='S'){
    const fwdY = y + (isRed? -1 : 1);
    if(inBounds(x,fwdY)) moves.push({from,to:idx(x,fwdY)});
    const crossed = isRed? (y<=4) : (y>=5);
    if(crossed){ if(inBounds(x+1,y)) moves.push({from,to:idx(x+1,y)}); if(inBounds(x-1,y)) moves.push({from,to:idx(x-1,y)}); }
  }
  return moves;
}

// Generate all legal moves for side
function generateAllMoves(side){
  const moves = [];
  for(let i=0;i<90;i++){ const p=board[i]; if(p==='.') continue; if(side==='r' && p.toUpperCase()!==p) continue; if(side==='b' && p.toLowerCase()!==p) continue; const ms = generateMoves(i); ms.forEach(m=>moves.push(m)); }
  return moves;
}

// Basic evaluation: material + simple position bonuses
function evaluatePosition(){
  let score=0;
  for(let i=0;i<90;i++){ const p=board[i]; if(p==='.') continue; score += pieceValue[p] || 0; }
  return score * (turn==='r'? 1 : 1); // sign consistent with AI's perspective during search
}

// Minimax with alpha-beta: AI assumes it's playing 'black' or 'red'
function minimax(depth, alpha, beta, maximizingPlayer, aiSideLocal){
  if(depth===0) return {score: evaluatePosition(), move: null};
  const side = maximizingPlayer? aiSideLocal : (aiSideLocal==='r'?'b':'r');
  const moves = generateAllMoves(side);
  if(moves.length===0) return {score: evaluatePosition(), move:null};
  let bestMove = null;
  if(maximizingPlayer){ let value = -Infinity; for(const m of moves){ const snapshot = board.slice(); const oldTurn = turn; makeMove(m,false); const res = minimax(depth-1, alpha, beta, false, aiSideLocal); board = snapshot; turn = oldTurn; if(res.score > value){ value = res.score; bestMove = m; } alpha = Math.max(alpha, value); if(alpha >= beta) break; } return {score:value, move:bestMove}; }
  else { let value = Infinity; for(const m of moves){ const snapshot = board.slice(); const oldTurn = turn; makeMove(m,false); const res = minimax(depth-1, alpha, beta, true, aiSideLocal); board = snapshot; turn = oldTurn; if(res.score < value){ value = res.score; bestMove = m; } beta = Math.min(beta, value); if(alpha >= beta) break; } return {score:value, move:bestMove}; }
}

// find and execute best AI move
function aiMove(){
  const side = aiSide; const maximizing = (side==='r');
  const depth = AI_DEPTH;
  const res = minimax(depth, -Infinity, Infinity, maximizing, side);
  if(res.move){ makeMove(res.move,true); moveHistory[moveHistory.length-1].san = formatMove(res.move); render(); afterMove(); }
}

function afterMove(){
  updateStatus();
  // check end conditions
  const redKing = board.findIndex(p=>p==='K'); const blackKing = board.findIndex(p=>p==='k');
  if(redKing===-1 || blackKing===-1){ alert('Game over'); }
  // if AI enabled and it's AI turn, run AI
  if(document.getElementById('autoAI').checked){ const sideNow = (turn==='r'?'r':'b'); if(sideNow===aiSide){ // delay for UX
      setTimeout(()=>{ AI_DEPTH = Number(document.getElementById('aiDepth').value); aiMove(); }, 300);
    }
  }
}

// UI wiring
render(); updateStatus();

document.getElementById('undoBtn').addEventListener('click', ()=>{ undo(); updateStatus(); });
document.getElementById('restartBtn').addEventListener('click', ()=>{ restart(); });
document.getElementById('toggleAI').addEventListener('click', (e)=>{ const cb=document.getElementById('autoAI'); cb.checked = !cb.checked; e.target.textContent = 'AI: ' + (cb.checked? 'On':'Off'); });
document.getElementById('aiDepth').addEventListener('change', (e)=>{ AI_DEPTH = Number(e.target.value); });
document.getElementById('autoAI').addEventListener('change', (e)=>{ document.getElementById('toggleAI').textContent = 'AI: ' + (e.target.checked? 'On':'Off'); });
document.getElementById('flipBoard').addEventListener('change',(e)=>{ flipView = e.target.checked; render(); });

// enable clicking on cells already rendered to reflect highlights
boardEl.addEventListener('click', ()=>{});

// initial AI side default: black
aiSide = 'b';

// expose some helpers for console debugging
window.app = {board, makeMove, generateMoves, generateAllMoves, aiMove, undo, restart};

</script></body>
</html>
